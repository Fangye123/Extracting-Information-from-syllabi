* * *

**TOWSON STATE UNIVERSITY

DEPARTMENT OF COMPUTER AND INFORMATION SCIENCES

COSC 612/614: SOFTWARE ENGINEERING I &II;

Professor A. Behforooz**  

    
    
    * * *
    
    **Office:		316L Stephens Hall
    Phone:		410-830-3035
    Fax:		410-830-3868
    E-mail:[behforooz-a@toe.towson.edu](mailto:behforooz-a@toe.towson.edu)
    		[alib@midget.towson.edu](mailto:alib@midget.towson.edu)
    

* * *

**

## Table of Contents

###

  * Course Description(COSC 612)
  * Course Description(COSC 614)
  * Course Objectives(COSC 612)
  * Course Objectives(COSC 614)
  * Textbook
  * Detailed Topics(COSC 612)
  * Course Requirements
  * Project(COSC 612 & COSC 614)
  * Requirements(COSC 612)
  * Requirements(COSC 614)
  * Grading Policy
  * References

* * *

## Course Description (COSC 612):

First semester of a two semester sequence dealing with the application of
formal software engineering principles and practices to the development of
embedded, computer based systems. The presentation of material is largely
qualitative and develops a structure for the second semester which emphasizes
quantitative aspects of Software Engineering.

* * *

## Course Description (COSC 614):

The second semester of the software engineering sequence will emphasis on: 1)
formal processes leading to development requirements and specifications that
will be turned over to coders; and 2) quantitative measures of usef ul
software attributes; and 3) the "support disciplines" such as human factors,
test and integration, reliability, real-time software, quality assurance,
logistics and their contributions to a successful software development cycle.
The specific product s expected from these areas will be discussed as will
their influence on software development. Finally the complete design and test
process will be studied in detail including a critical evaluation of current
design procedures and the common thread that b inds them.

* * *

## Course Objectives (COSC 612)

For the first semester the objectives are to develop a sense of how the
software engineering discipline fits into the overall system development
process and identify specific products, interfaces, and responsibilities of
contributing disciplines and organ izations. Stress will be placed on
identification and description of the many software and engineering fields
that are directly or indirectly involved in a successful software system
development. A comprehensive scription of the software engineering proce ss
will be presented along with a discussion of the approaches, methodologies and
tools available to the practicing software engineer.

* * *

## Course Objectives (COSC 614)

For the second semester the major objective is to explore those software
attributes that can be quantified and used as metrics in the treatment of
software products. Specifically: software reliability models; software
resource estimation models (Cost of development deployment and maintenance in
effort and support facilities); schedule estimation and planning; economic
justification studies and strategies; and software quality measures are among
software metrics that we will explore. A second objective is to present a
comprehensive treatment of software system test and integration approaches
using a real-world application project.

* * *

## Textbook

A. Behforooz, F. J. Hudson, **[Fundamentals of Software
Engineering](swp.html)** , Oxford University Press, 1996.

* * *

## Detailed Topics (COSC 612)

### _OVERVIEW OF SYSTEM AND SOFTWARE DEVELOPMENT LIFE CYCLES ( 1 week)_

  * System: Definition and Discussion 
    * System Characteristics 
    * Some Recurring Problems and Suggested Solutions in Large System Development 
    * Major Problems in System Development 
    * Some Suggested Solutions 
    * System Engineering 
    * System Analysis 
    * System Architecture and Design 
    * System Level Project Planning 
    * The System Development Plan 
      * Task Description 
      * Bottom up Resource and Schedule Estimation 
      * Staffing 
      * Technical Reviews 
      * Risk Assessment 
      * Change Control 
      * Appendices and References 
      * Keeping the Plan Current
    * The Software Development Plan 
  * System Development Life Cycle Definition and Overview 
  * System Development Life Cycle Models 
    * DOD type System Development Life Cycle 
    * MIS Oriented System Development Life Cycle
  * Software Development Life Cycle A brief Overview 
    * The DOD Model 
    * The NASA Model 
    * The Rapid throwaway Model 
    * The Incremental Development Model 
    * The Evolutionary Prototype Model 
    * The Reuse and Automated Development Model 
    * The resource and Schedule Driven Model 
    * The Cleanroom Approach
  * The Software Engineering Process

### _PROJECT DEFINITION (1 week)_

  * The XYZ Project: Problem Statement 
    * The XYZ Project: Analysis 
    * The Bidder Perspective 
    * The Proposal 
    * We Win
  * The ABC Project: Problem Statement 
  * The Truck/Driver Monitoring problem

### _TECHNICAL PLANNING (1 week)_

  * Software Development Planning 
    * Introduction 
    * Resource and Schedule Estimates 
    * Organizing and Staffing 
    * Work breakdown Structure, Work Packages and Cost Accounts 
      * Technical Management and Control 
      * Change Management 
      * Risk Containment 
      * Cost and Schedule Control 
      * Issue Resolution
    * Standards and Procedures 
    * Reviews, Audits and Walkthroughs 
    * The Development Environment 
    * Technical Performance Measurements 
    * Documentation 
    * Verification and Validation 
    * Maintenance 
    * Human Factors 
    * Delivery, Installation and Acceptance 
    * Appendices and References
  * The use of SDP as a Management Tool 
  * Attribute Estimation

### _SOFTWARE SPECIFICATIONS (1 week)_

  * People Involved in the Software Development process 
  * Software Requirement Specifications (SRS) 
    * Introductory Section of SRS 
    * General Description Section of SRS 
    * "Design-to" Specifications (Section 3 of SRS) 
    * Software Requirements Classification
  * An Example of SRS Preparation 
  * Other Software Specification Documents 
  * Software Specification Attributes

### _SOFTWARE SPECIFICATION TOOLS (2 weeks)_

  * Data Dictionary 
  * Decision Support Tools 
  * Data Flow Diagrams 
  * Entity-Relation Diagrams 
  * Finite State Machines 
  * Petri Nets 
    * Petri Net State Space 
    * Using Petri Net to Model a System 
    * Exercises
  * Mathematical Logic 
    * Problem Specification Using Logic

### _SOFTWARE DEVELOPMENT ENVIRONMENT (1 week)_

  * Software Development Environment Configuration 
  * Software Development Platform (SDPF) 
    * Essential Tools in a SDPF 
    * Very Useful Tools in a SDPF 
    * Useful Tools in a SDPF
  * Computer-Aided Software Engineering Tools 
    * CASE Tools Categorization 
    * Graphic Modeling 
    * CASE Repositories 
    * CASE Tools as an Aide to Re-engineering 
    * The Impact of Object-Oriented Methodology on CASE
  * An Ideal Software Development Platform

### _SOFTWARE DESIGN (1 week)_

  * An Overview of the Software Design Process 
    * Design requirements and Criteria 
    * Design Levels and Their Objectives 
    * IPO Approach 
    * Design Tools
  * Software Design 
    * The Seven Generic Design Steps 
    * The Component Design 
    * Preparing the Software Design Specification
  * A Design Example 
    * The Design Process

### _OBJECT-ORIENTED ANALYSIS AND DESIGN (2 weeks)

_

  * Object-Oriented Paradigm 
  * Basic Definitions and Symbols 
    * Objects 
    * Object Classes 
    * Relationship Among Objects 
      * Binary Relation 
      * n-ary Relation
    * Inheritance and Generalization 
    * Messages
  * Object-Oriented Analysis (OOA) 
    * Find Object Classes 
    * Find the Association Among Objects 
    * Determine Attributes of each Object Class 
    * Refine the Object Classes into Super and Sub Classes 
    * Check the Access Path Through Object Classes
  * An Example of Object-oriented Analysis 
  * Object-Oriented Design 
    * Determine External Inputs for Each Object Class 
    * Determine External Outputs of Each Object Class 
    * Define Services for Each Object Class 
    * Determine Instances and Connections for each Object Class 
    * Define Message Connections for Each Object Class
  * An Example of Object-oriented Design 
  * Software Reuse

### _FUNDAMENTALS OF CODING (1 week)_

  * Programming Languages 
    * Programming Languages Classification 
      * Procedural Languages 
      * Nonprocedural Languages 
      * Imperative Languages 
      * Declarative Languages 
      * Functional Languages 
      * Logic Languages 
      * Object-oriented Languages 
      * Fourth Generation Languages 
      * Fifth Generation Languages
    * Specific Features of Programming Languages 
      * Preprocessor, Naming Constraints, Named Constant, User-defined Data Type, Subprograms, Scoping, Recursive Subprograms, Available Operations, Variety of Control Structures, Data Structure Support, Data Abstraction and Information Hiding, Memory Allocation, File Handling Utilities, Access to other System Utilities, Compiler Capabilities, Programming Language Library, Exception Handling, Real-time Considerations, Concurrency Considerations, and Parallelism Consideration Selecting a Programming Language for Implementation
  * Programming Style and Program Quality 
    * Some Simple Style Rules 
    * Comment Statements 
    * Program Quality 
      * Readability, Understandability and Comprehensibility Logical Structure, Physical Layout, Robustness, CPU Efficiency, Memory Efficiency, Complexity, Human Factors, System Interfaces, and Reusable Code
  * A Programming Example 
    * Preliminary Design 
      * Analysis of the Preliminary Design 
      * Data Flow Diagram 
      * Main Data Structures 
      * High Level Program Design 
      * Detailed Design

### _SOFTWARE SYSTEM TEST AND INTEGRATION (1 week)_  
(Possible start of COSC 614)

  * Basic Concepts in Testing 
    * The Need for Planning 
    * The Test Phase 
    * Verification and Validation 
    * Reliability Models in testing 
    * Software Engineers Find a Career in Testing
  * An Overview of System and Software Test and Integration 
  * The Incremental Build of Modules into Systems 
  * System Test and Integration Plan 
  * The Build Test Plan and Specification 
  * Perspective on Build Testing 
  * Alpha and Beta Testing

### _MODULE LEVEL TESTING (1weeks)_

  * Module Test Planning 
    * Test Requirement Matrices 
    * The Module Test Plan
  * Static Testing 
    * Static Testing Tools
  * Dynamic Testing 
    * Black Box Testing 
    * White Box Testing 
    * An Example 
    * Computing Cyclomatic Complexity 
    * Dynamic Test Tools
  * Formal Testing 
    * Correctness of Program Structures 
    * Iteration Termination 
    * Correctness of Procedure Calls 
    * Remarks on Formal Testing
  * Test Case Execution 
    * Test Log Document 
    * Test Anomaly or Test Incident Document 
    * Test Summary Document
  * Closing Arguments

### _DEBUGGING (1 week)_

  * The Debugging Process 
    * Information gathering 
    * Fault Isolation 
      * Binary Partition Approach 
      * Structured Question and Answer Approach 
      * Involving Others Approach 
      * New Test Case Approach
    * Fault Confirmation 
    * Documentation 
    * Fixing the Fault 
    * New Testing
  * Recommendation 
  * A Debugging Example 
    * Test Case and Results 
    * Correcting the Program Module Faults 
    * New Testing

### _SOFTWARE MAINTENANCE AND MAINTAINABILITY (1 week)

_

  * Software Maintenance 
    * Maintenance Support Documents/Tools 
    * Using the Support Documentation
  * Software Maintenance Process 
  * Maintenance Resource Estimation 
  * Directly Specified Maintenance Attributes 
  * Reverse Engineering 
  * Re-engineering a Software Product

### _SOFTWARE ATTRIBUTES AND THEIR ESTIMATION (1 weeks)_

  * Identification Related Attributes 
  * Size Related Attributes 
    * Function Point Estimation 
    * Feature Point Estimation 
    * Converting Function Point Estimate to SLOC 
    * Source Line of Code Estimation
  * Design and Development Attributes 
  * Software Quality Attributes 
  * Complexity related Attributes 
  * Execution Time Attributes 
  * Test Related Attributes 
  * Documentation Related Attributes 
  * Performance Related Attributes 
  * Labor Related Attributes 
  * Operating Environment Attributes 
  * Data Collection Attributes

### _SOFTWARE DEVELOPMENT RESOURCE ESTIMATION (1 week)_

  * Software Product Cost and Schedule Estimation 
  * Cost and Schedule Estimation Models 
    * Constructive Cost Models (COCOMO) 
    * Basic COCOMO 
    * Intermediate COCOMO 
    * Estimation Process 
      * Organic Mode Characteristics 
      * Semidetached Mode Characteristics 
      * Embedded Mode Characteristics 
  * Grass Roots Resource and Schedule Estimation 
  * An Example of Schedule Development 
  * Closing Comments

### _SOFTWARE DEVELOPMENT RISK ASSESSMENT AND CONTAINMENT (1 week)_

  * Software Development Risk Areas 
  * The Risk Model 
  * Risk Containment and Risk Management 
  * Technical Performance Management 
  * Examples to Illustrate Software Development Risk Analysis

### _RELIABILITY (2 weeks)_

  * Overview 
  * Review of Probability Theory 
    * Axiomatic Probability 
      * Axioms of Probability
    * Conditional Probability 
      * Bayes Rule
    * Random Variables, Probability Distributions and Density Functions 
    * Distribution Functions 
      * Binomial Distribution 
      * Poisson Distribution 
      * Continuous Random Variables 
      * Normal Distribution 
      * Exponential Distribution 
      * Uniform Distribution
    * Joint Distribution of Random Variables 
    * Expectation of Random Variables --Moments 
    * Markov Process
  * Reliability Definitions 
  * Reliability Models 
  * Software Faults 
  * Design Rules 
  * System Reliability and Availability 
    * Availability
  * Applications of a Software Reliability Model 
  * Redundancy and Fault Tolerance 
  * Failure Modes and Effects and Other Analysis Tools

### _SOFTWARE QUALITY AND QUALITY ASSURANCE (1 week)_

  * Software Quality Assurance Planning 
    * Review as Quality Gates 
    * A Generic Software Quality Assurance Plan
  * Software Quality Assurance Process 
  * Software Quality Attributes 
  * Statistical Software Quality Assurance 
  * Guidelines and Checklists 
  * Software Safety

### REAL-TIME SOFTWARE (1 week)_

  * Real-time Requirements Specification 
  * Design Guidelines for Real-time Software 
  * Schedulability Concerns 
    * Task Synchronization 
    * Priority Inversion
  * Testing Real-time Software

### _HUMAN FACTORS IN SOFTWARE ENGINEERING (1 week)_

  * Human Factors History 
  * HCI Requirements and Design Process 
    * System Function Allocation 
    * Operational Timelines 
    * Operator Task Analysis 
    * HCI Design Approach 
    * HCI Testing
  * The Human as an Information System Component 
  * Operator Task Development 
    * Operator Requirements Specification
  * Operator Characteristics

### _COMMUNICATION SKILLS (1 week)

_ (class project is used)

  * Written Communications 
    * Determine the Audience 
    * Set Goals and Objectives 
    * Review the Results of Steps 1 and 2 
    * Outline and Story-board 
    * Review and Revise the Outline and the Story-board 
    * Expand the Story-board
  * The Oral Presentation 
    * Making the Oral Presentation
  * Meeting 
    * Brainstorming
  * Software Engineering Notebook 
  * Learning How to Listen

### _COST BENEFIT ANALYSIS AND TRADE-OFFS_

(class project is used )

  * Cost and Benefit 
  * Problem Definition 
  * Define Alternatives 
  * Evaluate Alternatives 
  * Sensitivity Analysis 
  * An Illustrative Example

### _REVIEWS ( 1 week)

_ (class project is used)

  * Formal Software related reviews 
  * Peer Reviews (Walkthroughs)

## _PROJECT PRESENTATIONS AND MEETINGS (2 weeks)

_

* * *

## Course Requirements

Students will be expected to gain a comprehensive understanding of the major
elements of the software and system development life cycle of a "typical"
embedded software system development. Students will develop a balanced, mature
outlook relative to the o les, responsibilities and products of the many
participants in such a development process, with emphasis on the role and
responsibilities of software engineers. It is expected that students will gain
a broader appreciation of the importance of software and software engineering
practice in an embedded computer system development. It is also expected that
students understand and appreciate the complex interrelationships that exist
among the many technical and management disciplines. Students must develop,
through team-work on class project, an appreciation for the team-work required
to produce a "goo d" software system.

* * *

## Project (COSC 612 & 614)

### STUDENT MUST WORK ON THE PROJECT AS A TEAM OF TWO

As a direct adjunct to this course, class project will be conducted using
students in the role of software engineers, programmers and testers. The
project will follow an accepted embedded computer system development
processes. The project source data will be drawn from either a contemporary
real-world project or from a scripted case study using an already completed
"real-world" project. The project will be initiated based on existing system
level functional and performance requirements documents, operatio nal
description documents, system design descriptions and rationale documents and
system requirement allocation to software. The project team will be expected
to read the documentation, perform the technical work and produce the
following documents:

### COSC 612 Project

  * Software Architecture Design (Due Oct. 17) 
  * Software Requirements Specification (functional and performance) (Due Nov. 14) 
  * Software development plan (Due November 14) 
  * First level design specification (Due December 12)

### COSC 614 Project

  * Software Design Specification --Detailed Level 
  * Software Test and Integration Plans and Procedures, including Test Cases 
  * Software Quality Assurance Plans 
  * Final Software Resource and Schedule Estimations  
**(the above documents are Due by midterm)**

  * Software Reliability Projections 
  * Real-time considerations, if applicable 
  * Coding and unit testing (Source code is the output here) 
  * Debugging  
**(Unit tested source code due end of April)**

  * Test and Integration (Test Anamoly Document is the Output) 
  * Acceptance test (Acceptance test document and verification of it should be the output) 
  * System Delivery  
**(Due during Final week)**

Students will be encouraged to commit to two consecutive semesters in order to
maintain project continuity. However, the projects will be designed to
accommodate student turnover by establishing a review at the close of the
first semester at a logical pr oject hand-off point.  

The objective of the project is to apply the methods and techniques developed
in lectures to "real-world" situations to accentuate some of the application
problems that must be resolved in order to bridge theory to practice.

* * *

## Requirements (COSC 612)

Exams| 70%  
---|---  
Project | 30%  
  
* * *

## Requirements (COSC 614)

Exams| 50%  
---|---  
Project | 50%  
  
* * *

## Grading Policy

Let us assume X is the highest score achieved in this course and T is your
total score. Compute **Z = Max((X+300)/2, 270)**. Your grade is:

    
    
    **A  	if   0.9 * Z < T <= 1.0 * Z
    	B  	if   0.8 * Z < T <= 0.9 * Z	
    	C  	if   0.7 * Z < T <= 0.8 * Z
    	F  	if   0.0 * Z < T <= 0.7 * Z
    **

* * *

## References

  1. Berzins and Luqi, **Software Engineering with Abstraction** , Addison-wesley, 1991. 

  2. Barry W. Boehm, **Software Engineering Economics** , Prentice-Hall, 1981. 

  3. C. Ghezzi, M. Jazayeri, D. Mandrioli, **Fundamentals of Software Engineering** , Prentice-Hall, 1992. 

  4. R. A. Radice, R. W. Phillips, **Software Engineering: An Industrial Approach** , Vol. 1, Prentice-Hall, 1988.

  5. Demillo et al, **Software Engineering and Evaluation** , Benjamin/ Cummings , 1987.

  6. Mark C. Paulk, Editor, **The Capability Maturity Model, Guidelines for Improving the Software Process** , SEI, Addison Wesley, 1995.

  7. J. R. Bourne, **Object-Oriented Engineering** , Irwin, 1992. 

  8. Grady Booch, **Object-Oriented Design with Applications** , 2nd ed. Benjamin/ Commings, 1995.

  9. Bernard Londeix, **Cost Estimation for Software Development** , Addison Wesley, 1987.

  10. Edited by N. Gehani and A. D. McGettrick, **Software Specification Techniques** , Assdison-Wesley, 1986.

  11. R. C. Backhouse, **Program Construction and Verification** , Prentice-Hall,1986. 

  12. Edited by N. Gehani, and A. D. McGettrick, **Concurrent Programming** , Addison-Wesley, 1988. 

  13. Sang H. Son, Editor, **Advances in Real-Time Systems** , Prentice-Hall, 1995.

  14. C. D. Sigwart, G. L. VanMeer, J. C. Hansen, **Software Engineering: A Project Oriented Approach** , Franklin, Beedle & Associates, 1990. 

  15. R. L. Glass, **Software Engineering and Computer Science: How do They Differ?** Springer-Verlag, 1987. 

  16. Bertrand Meyer, Reusable Software, **The base Object-Oriented Component Libraries** , Prentice-Hall, 1995. 
  17. D. Tkach, and R. Puttick, **Object Technology in Application Development** Benjamin/Cummings, 1994.

  18. R. Wirfs-Brock, B. Wilkerson, L. Wiener, **Designing Object-Oriented Software** , Prentice-Hall, 1990. 

  19. S. J. Sahni, **Software Development in Pascal** , Camelot, 1985. 

  20. B. Liskov, J. Guttag, **Abstraction and Specification in Program Development** , MIT Press/McGraw-Hill, 1986. 

  21. H. Abelson, G. J. Sussman, **Structure and Interpretation of Computer Programs** , MIT Press/McGraw-Hill, 1985. 

  22. D. A. Lamb, **Software Engineering: Planning for Change** , Prentice-Hall, 1988. 

  23. R. Fairley, **Software Engineering Concepts** , McGraw-Hill, 1985\. 

  24. D. V. Steward, **Software Engineering with System Analysis and Design** , Brooks/Cole, 1987. 

  25. Edited by Raymond T. Yeh, **Current Trends in Computer Programming Methodology** , Volume I Software Specification and Design, Prentice-Hall, 1977. 

  26. Edited by Raymond T. Yeh, **Current Trends in Computer Programming Methodology** , Volume II Program Validation, Prentice-Hall, 1977. 

  27. Edited by K. Manichandy and Raymond T. Yeh, **Current Trends in Computer Programming Methodology** , Volume III Software Modeling, Prentice-Hall, 1978.

  28. Edited by Raymond T. Yeh, **Current Trends in Computer Programming Methodology** , Volume IV Data Structures, Prentice-Hall, 1978.

  29. Edited by C. Anderson and M. Dorfman, **Aerospace Software Engineering, Progress in Astronautics and Aeronautics** , vol. 136, 1991. 

  30. R. S. Pressman, **Software Engineering: a Practitioner's Approach** , 4th edition, McGraw-Hill, 1997. 

  31. I. Sommerville, **Software Engineering** , 5th edition, Addison-Wesley, 1996. 

  32. Lou Mazzuchelli, **Lou Mazzuchelli On Software Engineering, Computer Design** , August 1991. 

  33. Fred L. Farmer, **Form Precedes Function** , Computer Word, Sept. 5, 1988. 

  34. Robert Haavind, **Software New Object Lesson** , Technology Review, February/March 1992.

  35. Martin L. Shooman, **Software Engineering: Design/Reliability/ management** , McGraw-Hill, 1983. 

  36. Fred Brooks, **Mythical Man Month** , 2nd Edition, Addison-wesley, 1995.

  37. Connie U. Smith, **Prformance Engineering of Software Systems** , Addison-Wesley, 1990. 

  38. J. Rumbaugh, et. al., **Object_Oriented Modeling and Design** , Prentice-Hall, 1991. 

  39. Watts S. Humphrey, **Managing the Software Process** , Addison-Wesley, 1989.

  40. Will Tracz, **Confessions of a Used Program Salesman: Institutionalizing Software Reuse** , Addison-Wesley, 1995. 

  41. Anton Eliens, **Principles of Object-Oriented Software Development** , Addison-Wesley, 1995. 

  42. Robert Rist and Robert Terwillinger, **Object-Oriented Programming in EIFFEL** , Prentice- Hall, 1995. 

  43. Alan Burns, Geoff Davies, **Concurrent Programming** , Addison Wesley, 1993.

  44. I. B. Wordsworth, **Software Development with Z, A practical Approach to Formal Methods in Software Engineering** , Addison Wesley, 1992.

  45. Coleman et. al. , **Object-Oriented Development: The Fusion Method** , Prentice-Hall, 1994. 

  46. Ian Graham, **Migration to Object Technology** , Addison Wesley, 1995.

  47. Dennis de Champeaux, **Object-Oriented Development Process and Metrics** , Prentice-Hall, 1997. 

  48. IEEE Software, Monthly publication of IEEE/CS Society. 

  49. IEEE Transaction on Software Engineering, Monthly Publication of IEEE/CS Sciety. 

  50. Software Engineering Notes, Quarterly Publication of the ACM Special Interest Group on Software Engineering. 

* * *

**Copyright (C) Prof. Ali Behforooz**

