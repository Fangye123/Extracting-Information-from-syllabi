Williams College CS137 - Programming Paradigms and Data Structures

# Williams College CS 137 Syllabus Fall 1994

### Instructor:

  * Kim B. Bruce 
  * 200 Bronfman 
  * Ext. 2273 

* * *

### Tentative Office Hours:

  * MWF 10-12, W 1:30-3, F 3:45 - 4:30, and by appointment 

* * *

###  T.A.:

Leaf Petersen is the CSCI 137 TA. He and/or other TA's will be available in
the CS Macintosh laboratory (BSC B28) from 7 to 11pm, Sunday through Thursday
evenings.

* * *

### Text:

None. Elements of ML Programming by Jefferey D. Ullman is recommended.

* * *

### Course Objectives:

The focus of this course will be on techniques for producing efficient and
correct programs to solve complex problems. We will combine attention to rapid
prototyping of complex problems with later study of efficient implementation
of complex data structures used to solve those problems. We will attain these
goals by beginning with the study of a high-level functional programming
language, ML, which will allow us to quickly produce correct programs, and
later shifting to an object-oriented extension of Pascal, which will allow us
to transform the earlier functional programs into much more efficient
programs. An on-going theme for the entire course is the design and efficient
implementation of reusable data structures which will allow us to easily solve
complex problems.

ML is a modern functional programming language which is in increasing use for
production-quality software. We will be using an implementation of Standard ML
on the Sun workstations owned by the CS department. For those who would like
to use it, there is a public-domain version available for the Macintosh.
Unfortunately, the error messages are not as good with that version.

Apple Computer added object-oriented extensions to Pascal in order to build
its innovative graphical operating system in 1984. In the second half of the
course we will use these extensions, which are built into the Think Pascal
compiler.

Students will be expected to write several programs, ranging from very short
programs to more elaborate systems. Since one of our goals in this course is
to teach you how to write large, reliable programs composed from reusable
pieces, we will be emphasizing the development of clear, modular programs that
are easy to read, debug, verify, analyze, and modify. We will emphasize the
use of rapid prototyping to quickly check out flaws in program designs.

### Workload and Grading:

Programs will be assigned weekly or biweekly. More short programs will be
assigned when we first introduce a language, while larger, more complex
programs will be assigned once students are familiar with the language. All
programs will be graded on documentation and style (40%), correctness (40%),
and efficiency (20%). Students should read and follow carefully the
programming standards in the department style guide as well as those given in
class in order to avoid losing significant points on style and documentation.
You will begin to appreciate the value of clear, well- documented programs as
you take programs written early in the semester and modify and enhance them
later.

Programs are due by 11:59pm on the date due (though I typically don't impose
the grade penalty for a program turned in within an hour of the deadline).
There will be a penalty assessed of 2^n % for a program which is n days late.
Programs will not be accepted more than five days late. It is usually better
to turn in a correct program one or two days late than a non-functioning
program on time. See the attached Department policy statement on late work.
All programs must be turned in to avoid a grade of failure in the course.

There will be two in-class **midterm exams** , tentatively scheduled for
**Thursday, 10/20** , and **Thursday, 11/17** , plus a scheduled final exam.
Homework exercises (non-programming assignments) will be assigned and
collected in class periodically. The grading will be weighted as follows:

    
        
      *  Final exam:        25%
    
      *  Midterms:          15% each
    
      *  Programs:          40%
    
      *  Homework & other:  5%
    
    

* * *

### SYLLABUS

The syllabus is likely to be modified in minor ways as appropriate during the
semester.

    
    
       Day         Topic
       ----------------------------------------------------------------
    
    
      1. 9/12        Introduction and Overview, Intro to ML
    
      2. 9/14        ML - expressions, basic data types, and functions
    
      3. 9/16        Complex data types: tuples, records, and lists
    
      4. 9/19        Pattern matching, type inference, and polymorphism
    
      5. 9/21        Mathematical induction and correctness
    
      6. 9/23        Sorting
    
      7. 9/26        More sorting and efficiency
    
      8. 9/28        User-defined data types
    
      9. 9/30        Abstypes
    
      10. 10/3        Stacks
    
      11. 10/5        Stacks - applications
    
      12. 10/7        Queues
    
      13. 10/10       Binary trees
    
      14. 10/12       Binary trees - applications
    
      15. 10/14	More Binary trees
    -----------------------------------------------------------------
    10/17       **Fall Reading Period**
    -----------------------------------------------------------------
    
      16.  10/19       Binary search trees
    -----------------------------------------------------------------
    10/20       **Hour Exam I**
    -----------------------------------------------------------------
    
      17.  10/21       Structures, signatures, and functors
    
      18. 10/24       What is object-oriented programming?
    
      19. 10/26       Objects in Think Pascal
    
      20. 10/28       Lists as objects
    
      21. 10/31       More lists
    
      22. 11/2        More lists
    
      23. 11/4        More lists & intro to stacks
    
      24. 11/7        Stacks and Queues
    
      25. 11/9        Trees & Binary search trees
    
      26. 11/11       Trees:  Heaps and Priority Queues
    
      27. 11/14       HeapSort 
    
      28. 11/16       Graphs I:  Specification and Applications
    -----------------------------------------------------------------
    11/17       Hour Exam II
    -----------------------------------------------------------------
    
      29. 11/18       Graphs II:  More Applications and Implementations
    
      30. 311/21      Graphs III:  More Applications and Implementations
    
      31. 11/23       Graphs IV:  More Implementations
    -----------------------------------------------------------------
                **Thanksgiving**
    -----------------------------------------------------------------
    
      32.  11/28       Balanced trees
    
      33. 11/30       Tables ADT
    
      34. 12/2        More tables, Hashing I
    
      35. 12/5        Hashing II
    
      36. 12/7        Building a better mousetrap (or OOL)
    
      37. 12/9        Summary:  Data Structures, prototyping, functional and
                object-oriented languages
    
    
    

[kim@cs.williams.edu](index.html)

